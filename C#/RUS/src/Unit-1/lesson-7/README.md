# Урок 7: Что такое актор в Proto.Actor.

В этом уроке мы познакомимся с основными свойствами акторов более подробно. И так преступим. Прежде всего, хотелось бы отметить, что модель акторов очень хорошо описывается одной фразой. **Все** **есть** **акторы** **(Everything is an actor)**.

Из этого следует что, акторы - это фундаментальные, примитивные вычислительные единицы, которые выполняют всю работу в нашей системе, или, другими словами, акторы - это строительные кирпичики нашей системы.

В приложении акторы, должны выполнять небольшие чётко определённые задачи, таким образом, наша приложение состоит из множества акторов, каждый из которых выполняет строго определённую задачу (Принцип единственной ответственности). 

Это означает, что создание приложения сводится к разделению задачи на небольшие подзадачи (Декомпозиции) и реализации этих подзадач в виде отдельных акторов.

Благодаря платформе Proto.Actor код актора одинаков, независимо от того, является ли он локальным или удалённым. Таким образом, актор будет вести себя одинаково, в не зависимости от того запущен он на локальной машине или же на удалённом сервере. 

Когда вы создаёте актор, вы не получаете прямой ссылки на него. Вместо этого Вы получаете PID (сокращение от process ID) - сериализуемый идентификатор, который используется для отправки сообщений актору. Преимуществом этого заключается в том, что PID можно легко сериализовать и пересылать с помощью сообщений, что позволяет акторам общаться удалённо.

Отправка сообщений это ключевой элемент в работе акторов. Акторы не делают прямой вызов методов другого актора, вместо этого они посылают сообщение, другому акторы с указанием выполнить какую либо команду. Это позволяет достичь слабосвязанности в системе.

Акторы - довольно ленивые штуки. Они просто сидят и ничего не делают. Если только мы не отправим им сообщение, так что если мы не посылаем им никаких сообщений, они просто сидят и ждут, пока не придёт какое либо сообщение, чтобы они могли приступить к работе.

По большому счету, есть четыре основные веши которые может делать актор. 

1. Получать и реагировать на сообщения.
2. Создавать больше актеров.
3. Отправлять сообщения другим акторам.
4. Изменить состояние для обработки следующего сообщения

Мы увидим примеры всех этих вещей на протяжении всего курса. 

Чтобы стало понятно, что за сущностью является актор, обратимся к частям из которых он состоит:

1. State.
2. Behavior.
3. Mailbox.
4. Child actors.
5. Supervisor strategy.

**State**

Объекты Actor обычно содержат поля, которые отражают состояние актора. Эти данные составляют ценность актора, и они должны быть защищены от прямого влияния, со стороны других акторов.

Одной из концепций акторов в Proto.Actor является то, что прямого обращения к экземпляру класса актора нет – невозможно вызвать метод актора. Единственный способ взаимодействия между акторами – общение при помощи асинхронных сообщений, что будет описано далее.

Из этого вытекает весомое преимущество акторов при разработке реактивных систем – не нужно синхронизировать доступ к актору при помощи блокировок, т.к. они де факто являются асинхронным. Следовательно, разработчик пишет логику работы актора, не беспокоясь о проблемах параллелизма вообще.

Поскольку состояние имеет критически важное значение для действий актора, наличие несогласованного состояния является фатальным. Таким образом, если актор выходит из строя и супервайзер перезапускает его, состояние актора будет сброшено до изначального, как при первом создании актора. Это позволяет решить проблему отказоустойчивости актора, позволяя системе самовосстанавливаться.

Однако существует возможность сконфигурировать актор так, что он сможет автоматически восстанавливаться в состояние до перезапуска.

**Behavior**

Поведение означает функцию, которая определяет действия, которые должны быть предприняты в ответ на сообщение, например, пересылать запрос, если клиент авторизован, отклонять и т.д.

Такое поведение может меняться со временем, например, потому что разные клиенты получают авторизацию с течением времени или потому, что актор может перейти в режим «без обслуживания». Поведение изменяется в зависимости от изменения переменных состояния, которые учитываются в логике работы актора, также сама функция может быть изменена во время выполнения.

При перезапуске актора его поведение сбрасывается до начального. Однако при помощи конфигураций можно автоматически восстанавливать поведение актора в состояние до перезапуска.

**Mailbox**

Цель актора – обработка сообщений, которые были отправлены от других акторов внутри системы или сообщения, которые поступают из внешних систем. Элемент, который соединяет отправителя и получателя – это почтовый ящик актора: каждый актор имеет ровно один почтовый ящик, в который отправители помещают свои сообщения. В силу того, что экземпляры актора могут выполняться на нескольких потоках одновременно, может показаться, что сообщения не имеют определённого порядка обработки, но это не так. Отправка нескольких сообщений от одного источника в один конкретный актор приведёт их в очередь в том же порядке.

Существуют разные варианты реализации почтовых ящиков, по умолчанию это FIFO: порядок сообщений, обрабатываемых актором, соответствует порядку, в котором они были установлены в очередь. В большинстве случаев это лучший выбор, но приложениям может потребоваться приоритизировать некоторые сообщения по сравнению с другими.

Алгоритм помещения сообщений в mailbox можно сконфигурировать, и выстраивать очередь в зависимости от приоритета сообщений или используя другой кастомный алгоритм. При использовании такой очереди порядок обработанных сообщений будет, естественно, определяться алгоритмом очереди и вообще не быть FIFO.

Важная особенность, в которой Proto.Actor отличается от некоторых других реализаций акторной модели, заключается в том, что текущее поведение актора всегда должно обрабатывать следующее сообщение из очереди. Но, при конфигурации из коробки, валидация (сможет ли актор с текущим поведением обработать поступившее сообщение) не происходит. Отказ от обработки сообщения обычно рассматривается как сбой.

**Child Actors**
Каждый актор потенциально является супервайзером: если он создаёт дочерние акторы для делегирования подзадач, он автоматически контролирует их. Список дочерних акторов поддерживается в контексте актора (стоит отметить, что потомки во втором поколении – “внуки”, не доступны напрямую) и доступен ему. Изменения в списке выполняются путём создания (context.actorOf (…)) или остановки (context.stop (child)) дочерних акторов. Фактически, действия по созданию и завершению дочерних акторов происходят асинхронным образом, поэтому они не блокируют свой супервизор.

**Supervisor strategy**
Последней частью актора является стратегия обработки сбоев в дочерних акторах. Стандартными стратегиями в случае сбоя в дочернем акторе являются:

- возобновить работу подчиненного актора, сохранить его состояние;
- возобновить работу подчиненного актора, восстановить его стандартное состояние;
- остановить работу подчиненного актора;
- передать сбой наверх (не рекомендуется, применяется в исключительных ситуациях).

Поскольку эта стратегия имеет концептуально важное значение для актора и его дочерних акторов, она не может быть изменена после создания актора.

Учитывая, что для каждого актора существует только одна такая стратегия, это означает, если возникает необходимость применять разные стратегии для подчинённых акторов, они должны быть сгруппированы под промежуточными акторами-супервайзерами с соответствующими стратегиями. Является хорошей практикой ещё раз структурировать акторные системы в соответствии с разделением задач на подзадачи.

Proto.Actor является асинхронной, неблокирующей и поддерживает обмен сообщениями. Она масштабируется как вертикально, так и горизонтально. Для поддержки отказоустойчивости в них предусмотрены механизмы слежения. Она соответствует всем требованиям, предъявляемым к созданию реактивных систем.