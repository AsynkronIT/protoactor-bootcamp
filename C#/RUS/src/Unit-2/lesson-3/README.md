# Урок 3: Определение сообщений.

После того как мы создали наши акторы. Следующий этап, заключается в определении сообщений, которые мы будем посылать между ними. В дополнение к отправке простых примитивных типов данных, которые существуют в .Net, таких как string или int, мы также можем определить свои собственные классы сообщений. 

Классы сообщений можно написать двумя способами, с использованием языка C# или же платформенно независимого языка Protobuf. 

Отличие этих способов создания сообщений, друг от друга заключается в том, что, при создании сообщения на языке C# вы можете использовать все типы данных доступные на платформе .Net. В свою очередь при использовании Protobuf выбор типов данных весьма ограничен. Но при использовании Protobuf вы сможете создавать акторы, которые смогут взаимодействовать с акторами, написанными на других языках программирования, чего не получится достичь при использовании сообщений написанных на C#. 

Так как отличительной особенностью платформы Proto.Actor является возможность написания акторов на разных языках программирования, вы должны всегда стараться использовать Protobuf для написания сообщений. И использовать C# только в исключительных случаях. Для того чтобы в дальнейшем ваша система могла взаимодействовать с акторами на других языках программирования.

#### Как создавать сообшение с использованием C#.

Итак, для начала мы просто создадим простой класс в нашей IDE. В отличие от создания актора, где нам приходилось наследоваться от специального базового класса. Класс сообщения не нуждается в наследовании от какого-либо базового класса или интерфейса.

Далее, мы можем добавить свойства к нашему классу сообщений, чтобы определить данные, которые мы хотим передать внутри сообщения. Когда сообщение отправляется актору, актор может извлечь эти данные из свойств и использовать их.

Последнее, что мы должны сделать, это сделать свойства нашего класса доступными только для чтения. И задать конструктор, который принимает начальные значения свойств и затем устанавливает их, используя закрытый сеттеры. Тем самым мы можем быть уверены, что как только мы создали экземпляр сообщения, оно будет доступно только для чтения.

В конце наше сообщение должно выглядеть примерно так.

```c#
private class Hello
{
    public string Who { get; }

    public Hello(string who)
    {
        Who = who;
    }
}
```

При создании сообщений мы должны, стараться придерживаться определённых best practices которые существуют при работе с сообщениями.

Главное правило заключается в том, что мы не должны передавать изменчивое состояние между акторами. Одно из главных преимуществ использования модели акторов это значительное упрощает параллельного программирования. Если же мы начнём передавать изменчивое состояние между акторами, то мы вернёмся к старым проблемам, связанным с блокировкой общих ресурсов. 

Поэтому мы должны создавать неизменяемые сообщения. То есть наши сообщения должны быть потокобезопасны. Это позволит нам передавать их в любом месте системы, не беспокоясь о том, что мы разделяем изменчивые состояния между акторами. 

#### Как создавать сообшение с использованием gRPC и Protobuf.

**gRPC** — это высокопроизводительный фреймворк разработанный компанией Google для вызов удаленных процедур (RPC), работает поверх HTTP/2.

gRPC простой в использовании, отлично подходит для создания распределенных систем (микросервисов) и API. Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов. Есть возможность создавать клиентские библиотеки для работы с бэкендом на 10 языках. Высокая производительность достигается за счет использования протокола HTTP/2 и Protocol Buffers.

## Protocol Buffers (protobuf)

[Protobuf](https://developers.google.com/protocol-buffers/) формат сериализации используемый по умолчанию для передачи данных между клиентом и сервером. Используя строгую типизацию полей и бинарный формат для передачи структурированных данных потребляет меньше ресурсов. Время выполнения процесса сериализации/десериализации значительно меньше как и размер сообщений в отличии от JSON/XML.

Для написания protobuf файлов используют язык описания интерфейсов (IDL). Например, чтобы описать структуру данных сообщения, нужно добавить message, имя структуры, а внутри тип, название и номер поля. Номера полей очень важны для обратной совместимости, поэтому не стоит менять их последовательность при добавлении или удалении полей. Старые номера можно резервировать. 

### Определение актора

gRPC использует подход "contract-first", то есть вначале определяется контракт - общее определение сервиса, которое определяет механизм взаимодействия. Давайте для примера рассмотрим простой контракт.

```protobuf
syntax = "proto3";
 
option csharp_namespace = "SimpleGrpcService";
 
package greet;

message HelloRequest {
  string name = 1;
}
 
message HelloReply {
  string message = 1;
}
```

Определение этого файла может напоминать синтаксис C#, но в реальности это синтаксис proto, который используется для описания сервиса gPRC. Хотя в целом это си-подобный синтаксис, поэтому ориентироваться в нем не так сложно.

Самая первая строка определяет тип используемого синтаксиса:

```protobuf
syntax = "proto3";
```

В данном случаем применяется синтаксис "proto3". На сегодняшний момент в природе также имеется версия "proto2", которая является более старой.

Далее указывается пространство имен, которое будет использоваться с этим сервисом:

```protobuf
option csharp_namespace = "TestGrpcService";
```

По умолчанию это название проекта. И соответственно генерируемые классы будут помещаться в даное пространство имен.

Следующая строка с помощью оператора **package** определяет название пакета:

```protobuf
package greet;
```

В данном случае пакет называется "great". Установка пакета позволяет разрешить конфликты имен при наличие сущностей с одинаковыми именами.

Далее идет определение используемых сообщений:

```protobuf
message HelloRequest {
  string name = 1;
}
 
message HelloReply {
  string message = 1;
}
```

Сообщение представляет специальную сущность, которая содержит пересылаемые данные. Сообщение определяет набор полей, для которых определен тип. Каждое поле представляет некоторый кусочек информации, посылаемой в сообщении. Так, в обоих сообщениях определены два поля типа string, то есть в каждом сообщении будут отправляться некоторая строка.

Proto3 поддерживает использование многих стандартных примитивных типов, которые применяются в ряде наиболее популярных языков программирования, например, `bool, int32, float, double` и `string`. Таким образом, можно пересылать различные по характеру данные. Также в качестве типа полей сообщений можно использовать ранее определенные типы сообщений.

Каждому полю в сообщении присваивается уникальное число, например, в примере выше полям обоих сообщений присваивается единица (в `string name = 1` или в `string message = 1`). Эти значения позволяют идентифицировать непосредственные значения полей в бинарном формате при кодировании и получении сообщений. При использовании чисел от 1 до 15 в качестве значения в бинаром представлении в сообщение добавляется дополнительный байт. Значения от 16 до 2047 добавляют два дополнительных байта. Поэтому для наиболее часто используемых в сообщении данных лучше указывать значения от 1 до 15. Допустимые значения: от 1 до 536870911 (з исключением диапазона чисел от 19000 до 19999)..

В дальнейшем компилятор сгенерирует класс, который сооветствует определению в файле `*.proto`.

Подробное руководство по синтаксису protobuf можно найти на https://developers.google.com/protocol-buffers/docs/proto3 и https://developers.google.com/protocol-buffers/docs/csharptutorial

Используя подобный подход, мы можем абстрагироваться от конкретного языка и описывать взаимодействия сервера и клиент в терминах языка Proto. А затем для каждого конкреного языка (C#, Java и т.д.) определить соответствующую реализацию.