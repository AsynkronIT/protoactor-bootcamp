# Урок 5: Канал DeadLetter.

DeadLetter - это канал, или очередь, недоставленных сообщений. Он хранит все сообщения, которые не были обработаны или доставлены. Это самый обычный канал, но чаще всего он не используется для отправки сообщений. Только когда обнаруживаются какие-то проблемы с сообщением, например если оно не может быть доставлено, такое сообщение автоматически помещается в данный канал, как показано на рисунке.

![](images/6_5_1.png)

Осуществляя мониторинг этого канала, можно узнать, какие сообщения не были обработаны, и предпринять необходимые действия. В частности, в ходе тестирования системы с помощью этой очереди можно выяснить, почему некоторые сообщения остаются необработанными. Если система не должна просто сбрасывать какие-либо сообщения, эту очередь можно использовать для повторной отправки сообщений после решения проблем.

Для реализации очереди недоставленных сообщений в Proto.Actor используется EventStream. Когда сообщение доставляется в почтовый ящик уже завершившегася актора или посылается после его завершения, оно попадает в EventStream системы акторов ActorSystem. Сообщение заворачивается в класс DeadLetterEvent, содержащий оригинальное сообщение, адрес отправителя и адрес получателя. То есть фактически очередь недоставленных сообщений интегрирована в общую очередь EventStream. Чтобы получить недоставленные сообщения, достаточно подписать актора на получение из EventStream сообщений типа `DeadLetterEvent()`. Пример с подпиской на определённый тип сообщений, описывался в предыдущем уроке.

Давайте рассмотрим небольшой пример. Создадим простой актор Echo, возвращающий любые сообщения обратно отправителю, и после его запуска сразу же пошлём ему сообщение PoisonPill. Это приведёт к завершению актора. Из листинга видно, что сообщение можно получить, подписавшись на получение сообщений типа `DeadLetterEvent()`.

```c#
static async Task Main(string[] args)
{
    var system = new ActorSystem();
    var props = Props.FromProducer(() => new Echo());
    var pid = system.Root.Spawn(props);

    system.EventStream.Subscribe<DeadLetterEvent>(msg => Console.WriteLine($"Sender: {msg.Sender}, Pid: {msg.Pid}, Message: {msg.Message}"));

    system.Root.Send(pid, new TestMessage());
    await system.Root.PoisonAsync(pid);
    system.Root.Send(pid, new TestMessage());

    Console.ReadLine();
}
```

Сообщения, посланные завершившемуся актору, не могут быть обрабо­таны, и pid на этот актор не должна больше использоваться. Когда сообщения посылаются завершившемуся актору, они попадают в очередь DeadLetter. Это подтверждает получение сообщения нашим обработчиком.

```c#
system.EventStream.Subscribe<DeadLetterEvent>(msg => Console.WriteLine($"Sender: {msg.Sender}, Pid: {msg.Pid}, Message: {msg.Message}"));
```

Очередь DeadLetter можно также использовать для хранения сообщений, которые не удалось обработать. Но решение об этом принимается на уровне каждого конкретного актора. Актор может выяснить, что не способен обработать полученное сообщение и не знает, что с ним делать. В такой ситуации сообщение можно послать в очередь недоставленных сообщений. В системе акторов ActorSystem имеется ссылка на актор DeadLetter. Когда возникает необходимость послать сообщение в очередь недоставленных сообщений, его можно передать этому актору:

```c#
System.DeadLetter.SendUserMessage(Self, msg);
```

